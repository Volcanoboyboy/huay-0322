# mysql数据库

## 课程目标

- 理解mysql基本使用
- 掌握一些mysql使用技巧

## why

- 前面学习过非关系型数据库mongoDb和redis，结合mysql全面掌握各种类型数据库的应用场景

### 环境准备

1. 进入https://hub.docker.com/
2. 搜索mysql，进入tags选择对应的版本
3. docker pull xxx:xxx

4. 使用docker安装mysql8.0环境

` docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=secret -d mysql:8.0 --default-authentication-plugin=mysql_native_password`

5. 进入容器内部

`docker exec -it mysql bash`

6. 运行mysql

`mysql -u xxx -p`

## 第一章 mysql 基础

### 数据类型

#### 整数类型

**TINYINT**        1字节        (-128，127)          (0，255)            小整数值 

**SMALLINT**       2字节     (-32 768，32 767)       (0，65 535)         大整数值 

**MEDIUMINT**      3字节    (-8 388 608，8 388 607) (0，16 777 215)      大整数值 

**INT或INTEGER**   4字节   (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 

**BIGINT**         8字节   (-9 233 372 036 854 775 808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 

**FLOAT**          4字节   (-3.402 823 466 E+38，1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度浮点数值 

**DOUBLE**         8字节 (1.797 693 134 862 315 7 E+308，2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度浮点数值 



#### 字符串类型

**CHAR**         0-255字节          定长字符串 

**VARCHAR**      0-255字节          变长字符串 

**TINYBLOB**     0-255字节        不超过 255 个字符的二进制字符串 

**TINYTEXT**     0-255字节        短文本字符串 

**BLOB**         0-65535字节      二进制形式的长文本数据 

**TEXT**         0-65535字节      长文本数据 

**MEDIUMBLOB**   0-16 777 215字节 二进制形式的中等长度文本数据 

**MEDIUMTEXT**   0-16 777 215字节 中等长度文本数据 

**LOGNGBLOB**    0-4 294 967 295字节 二进制形式的极大文本数据 

**LONGTEXT**     0-4 294 967 295字节 极大文本数据

VARBINARY**(M)                   允许长度0-M个字节的定长字节符串，值的长度+1个字节

**BINARY**(M)    M                 允许长度0-M个字节的定长字节符串



#### 日期类型

 **DATE**       4        1000-01-01/9999-12-31 YYYY-MM-DD    日期值 

 **TIME**       3        '-838:59:59'/'838:59:59' HH:MM:SS    时间值或持续时间 

 **YEAR**       1         1901/2155               YYYY       年份值 

 **DATETIME**   8       1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 

 **TIMESTAMP**  4       1970-01-01 00:00:00/2037 年某时 YYYYMMDD HHMMSS 混合日期和时间值，时间戳



#### 复合类型

**ENUM 类型**

　　ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。ENUM 类型字段可以从集合中取得一个值或使用 null 值，

除此之外的输入将会使 MySQL 在这个字段中插入一个空字符串。另外如果插入值的大小写与集合中值的大小写不匹配，MySQL 会自动使用插入值的大小写转换成与集合中大小写一致的值。

**SET 类型**

　SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。并且与 ENUM 类型相同的是任何试图在 SET 类型字段中插入非预定义的值都会使 

MySQL 插入一个空字符串。如果插入一个即有合法的元素又有非法的元素的记录，MySQL 将会保留合法的元素，除去非法的元素。



### Show

`SHOW DATABASES`

SHOW DATABASES;返回可用数据库的一个列表。包含在这个列 

表中的可能是MySQL内部使用的数据库(如例子中的mysql和 information_schema)。当然，你自己的数据库列表可能看上去与这里的 不一样。 



`SHOW TABLES`

为了获得一个数据库内的表的列表，使用SHOW TABLES;



SHOW也可以用来显示表列:

`SHOW COLUMNS FROM customers`

SHOW COLUMNS要求给出一个表名(这个例子中的FROM 

customers)，它对每个字段返回一行，行中包含字段名、数据 类型、是否允许NULL、键信息、默认值以及其他信息(如字段cust_id 的auto_increment)。 

> 什么是自动增量? 某些表列需要唯一值。例如，订单编号、
> 雇员ID或(如上面例子中所示的)顾客ID。在每个行添加到表
> 中时，MySQL可以自动地为每个行分配下一个可用编号，不
> 用在添加一行时手动分配唯一值(这样做必须记住最后一次使
> 用的值)。这个功能就是所谓的自动增量。如果需要它，则必
> 须在用CREATE语句创建表时把它作为表定义的组成部分。

> DESCRIBE语句 MySQL支持用DESCRIBE作为SHOW COLUMNS
> FROM的一种快捷方式。换句话说，DESCRIBE customers;是
> SHOW COLUMNS FROM customers;的一种快捷方式。

### 检索

`SELECT prod_name FROM products`

> 如果读者自己试验这个查询，可能会发现显示输
> 出的数据顺序与这里的不同。出现这种情况很正常。如果没有
> 明确排序查询结果(下一章介绍)，则返回的数据的顺序没有
> 特殊意义。返回数据的顺序可能是数据被添加到表中的顺序，
> 也可能不是。只要返回相同数目的行，就是正常的。

> 结束SQL语句 多条SQL语句必须以分号(;)分隔。MySQL
> 如同多数DBMS一样，不需要在单条SQL语句后加分号。但特
> 定的DBMS可能必须在单条SQL语句后加上分号。当然，如果
> 愿意可以总是加上分号。事实上，即使不一定需要，但加上
> 分号肯定没有坏处。如果你使用的是mysql命令行，必须加上
> 分号来结束SQL语句。



`SELECT pro_id, prod_name, prod_price FROM products`

> 从上述输出可以看到，SQL语句一般返回原始的、
> 无格式的数据。数据的格式化是一个表示问题，而不是一个
> 检索问题。因此，表示(对齐和显示上面的价格值，用货币
> 符号和逗号表示其金额)一般在显示该数据的应用程序中规
> 定。一般很少使用实际检索出的原始数据(没有应用程序提
> 供的格式)。



`SELECT * FROM products`

除了指定所需的列外(如上所述，一个或多个列)，SELECT语句还可
以检索所有的列而不必逐个列出它们。



`SELECT DISTINCT vend_id FROM productis`

SELECT DISTINCT vend_id告诉MySQL只返回不同(唯一)的 

vend_id行 。

> 不能部分使用DISTINCT DISTINCT关键字应用于所有列而
> 不仅是前置它的列。如果给出SELECT DISTINCT vend_id,
> prod_price，除非指定的两个列都不同，否则所有行都将被
> 检索出来。



`SELECT * FROM products LIMIT 5`

为得出下一个5行，可指定要检索的开始行和行数

`SELECT * FROM products LIMIT 5,5`

> 行0 检索出来的第一行为行0而不是行1。因此，LIMIT1,1
> 将检索出第二行而不是第一行。

> 在行数不够时 LIMIT中指定要检索的行数为检索的最大行
> 数。如果没有足够的行(例如，给出LIMIT 10, 5，但只有13
> 行)，MySQL将只返回它能返回的那么多行。



### 排序

`SELECT prod_name FROM products ORDER BY  prod_name` 

> 这条语句除了指示MySQL对prod_name列以字母顺序排序数据
> 的ORDER BY子句外，与前面的语句相同



`SELECT prod_name FROM products ORDER BY  prod_name, prod_price`

经常需要按不止一个列进行数据排序。例如，如果要显示雇员清单，
可能希望按姓和名排序(首先按姓排序，然后在每个姓中再按名排序)。
如果多个雇员具有相同的姓，这样做很有用。



下面的例子按价格以降序排序产品(最贵的排在最前面):

`SELECT prod_name FROM products ORDER BY  prod_price DESC	` 

> 数据排序不限于升序排序(从A到Z)。这只是默认的排序顺序，还可
> 以使用ORDER BY子句以降序(从Z到A)顺序排序。为了进行降序排序，
> 必须指定DESC关键字。



使用ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。 

下面的例子演示如何找出最昂贵物品的值: 

`SELECT prod_price FROM products ORDER BY prod_price DESC LIMIT 1;`



### 过滤数据

`SELECT * FROM products WHERE prod_price = 10`

这个例子采用了简单的相等测试:它检查一个列是否具有指定的值，
据此进行过滤。但是SQL允许做的事情不仅仅是相等测试。

**WHERE子句操作符**

![image-20191122160839661](/Users/itheima/Library/Application Support/typora-user-images/image-20191122160839661.png)



在创建表时，表设计人员可以指定其中的列是否可以不包含值。在 

一个列不包含值时，称其为包含空值NULL。

`SELECT * FROM products WHERE prod_price IS NULL`the 

#### AND 操作符

`SELECT * FROM products WHERE prod_price = 10 AND xxxx < 90`



#### OR 操作符

`SELECT * FROM products WHERE prod_price = 10 OR xxxx < 90`



但是，组合AND和OR带来了一个有趣的问题。为了说明这个问题，来
看一个例子。假如需要列出价格为10美元(含)以上且由1002或1003制
造的所有产品。下面的SELECT语句使用AND和OR操作符的组合建立了一个
WHERE子句:

![image-20191122163416367](/Users/itheima/Library/Application Support/typora-user-images/image-20191122163416367.png)

> SQL(像多数语言一样)在处理OR操作符前，优先处理AND操
> 作符。当SQL看到上述WHERE子句时，它理解为由供应商1003制造的任何
> 价格为10美元(含)以上的产品，或者由供应商1002制造的任何产品，
> 而不管其价格如何。换句话说，由于AND在计算次序中优先级更高，操作
> 符被错误地组合了。

此问题的解决方法是使用圆括号明确地分组相应的操作符。请看下
面的SELECT语句及输出:

![image-20191122163509524](/Users/itheima/Library/Application Support/typora-user-images/image-20191122163509524.png)

#### IN操作符

圆括号在WHERE子句中还有另外一种用法。IN操作符用来指定条件范
围，范围中的每个条件都可以进行匹配。IN取合法值的由逗号分隔的清
单，全都括在圆括号中。

![image-20191122163615629](/Users/itheima/Library/Application Support/typora-user-images/image-20191122163615629.png)

为什么要使用IN操作符?其优点具体如下。 

- 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。  在使用IN时，计算的次序更容易管理(因为使用的操作符更少)。 

- IN操作符一般比OR操作符清单执行更快。
-  IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。

#### NOT操作符

WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所
跟的任何条件。

![image-20191122163912374](/Users/itheima/Library/Application Support/typora-user-images/image-20191122163912374.png)



### 用通配符进行过滤

最常使用的通配符是百分号(%)。在搜索串中，%表示任何字符出现
任意次数。

![image-20191122164047282](/Users/itheima/Library/Application Support/typora-user-images/image-20191122164047282.png)

> 此例子使用了搜索模式'jet%'。在执行这条子句时，将检索任 
>
> 意以jet起头的词。%告诉MySQL接受jet之后的任意字符，不 管它有多少字符。 



通配符可在搜索模式中任意位置使用，并且可以使用多个通配符。
下面的例子使用两个通配符，它们位于模式的两端:

![image-20191122164212556](/Users/itheima/Library/Application Support/typora-user-images/image-20191122164212556.png)



通配符也可以出现在搜索模式的中间，虽然这样做不太有用。下面
的例子找出以s起头以e结尾的所有产品:

![image-20191122164233091](/Users/itheima/Library/Application Support/typora-user-images/image-20191122164233091.png)

> 重要的是要注意到，除了一个或多个字符外，%还能匹配0个字符。%
> 代表搜索模式中给定位置的0个、1个或多个字符。

#### 下划线通配符

另一个有用的通配符是下划线(_)。下划线的用途与%一样，但下划 

线只匹配单个字符而不是多个字符。 

![image-20191122164406493](/Users/itheima/Library/Application Support/typora-user-images/image-20191122164406493.png)

#### 使用通配符的技巧

正如所见，MySQL的通配符很有用。但这种功能是有代价的:通配 符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一 些使用通配符要记住的技巧。 

- 不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。 

- 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。
- 把通配符置于搜索模式的开始处，搜索起 来是最慢的。 



### 计算字段

存储在数据库表中的数据一般不是应用程序所需要的格式。下面举 

几个例子。 

- 如果想在一个字段中既显示公司名，又显示公司的地址，但这两 个信息一般包含在不同的表列中。 

- 城市、州和邮政编码存储在不同的列中(应该这样)，但邮件标签 打印程序却需要把它们作为一个恰当格式的字段检索出来。 

- 列数据是大小写混合的，但报表程序需要把所有数据按大写表示 出来。 

- 物品订单表存储物品的价格和数量，但不需要存储每个物品的总 价格(用价格乘以数量即可)。为打印发票，需要物品的总价格。 

- 需要根据表数据进行总数、平均数计算或其他计算。 

> MySQL的不同之处 多数DBMS使用+或||来实现拼接，
> MySQL则使用Concat()函数来实现。当把SQL语句转换成
> MySQL语句时一定要把这个区别铭记在心。

![image-20191122165303902](/Users/itheima/Library/Application Support/typora-user-images/image-20191122165303902.png)

#### 使用别名

从前面的输出中可以看到，SELECT语句拼接地址字段工作得很好。
但此新计算列的名字是什么呢?实际上它没有名字，它只是一个值。如
果仅在SQL查询工具中查看一下结果，这样没有什么不好。但是，一个未
命名的列不能用于客户机应用中，因为客户机没有办法引用它。

![image-20191122165425563](/Users/itheima/Library/Application Support/typora-user-images/image-20191122165425563.png)

> SELECT语句本身与以前使用的相同，只不过这里的语句中计算 
>
> 字段之后跟了文本AS vend_title。它指示SQL创建一个包含 指定计算的名为vend_title的计算字段。从输出中可以看到，结果与以 前的相同，但现在列名为vend_title，任何客户机应用都可以按名引用 这个列，就像它是一个实际的表列一样。 

#### 执行算数计算

![image-20191122165535497](/Users/itheima/Library/Application Support/typora-user-images/image-20191122165535497.png)

> 输出中显示的expanded_price列为一个计算字段，此计算为 
>
> quantity*item_price。客户机应用现在可以使用这个新计算 列，就像使用其他列一样。 



### 使用数据处理函数

- 用于处理文本串(如删除或填充值，转换值为大写或小写)
- 算数操作
- 处理日期

#### upper

这次使用Upper()函数:

![image-20191122170526226](/Users/itheima/Library/Application Support/typora-user-images/image-20191122170526226.png)

正如所见，Upper()将文本转换为大写，因此本例子中每个供 

应商都列出两次，第一次为vendors表中存储的值，第二次作 为列vend_name_upcase转换为大写。 



#### SOUNDEX

SOUNDEX是一个将任何文
本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似
的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然
SOUNDEX不是SQL概念，但MySQL(就像多数DBMS一样)都提供对
SOUNDEX的支持。

下面给出一个使用Soundex()函数的例子。customers表中有一个顾
客Coyote Inc.，其联系名为Y.Lee。但如果这是输入错误，此联系名实
际应该是Y.Lie，怎么办?显然，按正确的联系名搜索不会返回数据，如
下所示:

![image-20191122170633172](/Users/itheima/Library/Application Support/typora-user-images/image-20191122170633172.png)

现在试一下使用Soundex()函数进行搜索，它匹配所有发音类似于
Y.Lie的联系名:

![image-20191122170805681](/Users/itheima/Library/Application Support/typora-user-images/image-20191122170805681.png)

#### 日期处理

日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和 

有效地排序或过滤，并且节省物理存储空间。 

一般，应用程序不使用用来存储日期和时间的格式，因此日期和时 间函数总是被用来读取、统计和处理这些值。由于这个原因，日期和时 间函数在MySQL语言中具有重要的作用。 

![image-20191122171148778](/Users/itheima/Library/Application Support/typora-user-images/image-20191122171148778.png)

> 首先需要注意的是MySQL使用的日期格式。无论你什么时候指定一
>
> 个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为
> 格式yyyy-mm-dd。因此，2005年9月1日，给出为2005-09-01。虽然其他的
> 日期格式可能也行，但这是首选的日期格式，因为它排除了多义性(如，
> 04/05/06是2006年5月4日或2006年4月5日或2004年5月6日或......)。

![image-20191122171553764](/Users/itheima/Library/Application Support/typora-user-images/image-20191122171553764.png)

> 但是，使用WHERE order_date = '2005-09-01'可靠吗?order_
> date的数据类型为datetime。这种类型存储日期及时间值。样例表中
> 的值全都具有时间值00:00:00，但实际中很可能并不总是这样。如果
> 用当前日期和时间存储订单日期(因此你不仅知道订单日期，还知道
> 下订单当天的时间)，怎么办?比如，存储的order_date值为
> 2005-09-01 11:30:05，则WHERE order_date = '2005-09-01'失败。
> 即使给出具有该日期的一行，也不会把它检索出来，因为WHERE匹配失
> 败。

![image-20191122175257598](/Users/itheima/Library/Application Support/typora-user-images/image-20191122175257598.png)

> 如果要的是日期，请使用Date() 如果你想要的仅是日期， 则使用Date()是一个良好的习惯，即使你知道相应的列只包 含日期也是如此。这样，如果由于某种原因表中以后有日期和 时间值，你的SQL代码也不用改变。当然，也存在一个Time() 函数，在你只想要时间时应该使用它。 
>
> Date()和Time()都是在MySQL 4.1.1中第一次引入的。 

不过，还有一种日期比较需要说明。如果你想检索出2005年9月下的
所有订单，怎么办?简单的相等测试不行，因为它也要匹配月份中的天
数。有几种解决办法，其中之一如下所示:

![image-20191122175621515](/Users/itheima/Library/Application Support/typora-user-images/image-20191122175621515.png)

还有另外一种办法(一种不需要记住每个月中有多少天或不需要操
心闰年2月的办法):

![image-20191122175646284](/Users/itheima/Library/Application Support/typora-user-images/image-20191122175646284.png)



### 汇总数据

![image-20191122175722044](/Users/itheima/Library/Application Support/typora-user-images/image-20191122175722044.png)



AVG()通过对表中行数计数并计算特定列值之和，求得该列的平均
值。AVG()可用来返回所有列的平均值，也可以用来返回特定列或行的平
均值。

![image-20191122175748171](/Users/itheima/Library/Application Support/typora-user-images/image-20191122175748171.png)

### 联结表

SQL最强大的功能之一就是能在数据检索查询的执行中联结(join) 表。联结是利用SQL的SELECT能执行的最重要的操作，很好地理解联结 及其语法是学习SQL的一个极为重要的组成部分。 

#### 内联结

关键字：inner join on

语句：select * from a_table a inner join b_table bon a.a_id = b.b_id;

说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。

![image-20191123010748733](/Users/itheima/Library/Application Support/typora-user-images/image-20191123010748733.png)

#### 左联结

关键字：left join on / left outer join on

语句：select * from a_table a left join b_table bon a.a_id = b.b_id;

说明：

left join 是left outer join的简写，它的全称是左外连接，是外连接中的一种。

左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。

![image-20191123011027068](/Users/itheima/Library/Application Support/typora-user-images/image-20191123011027068.png)

#### 右联结

关键字：right join on / right outer join on

语句：select * from a_table a right outer join b_table b on a.a_id = b.b_id;

说明：

right join是right outer join的简写，它的全称是右外连接，是外连接中的一种。

与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。

#### 不建议使用外键

首先我们明确一点，外键约束是一种约束，这个约束的存在，会保证表间数据的关系“始终完整”。因此，外键约束的存在，并非全然没有优点。
比如使用外键，可以

- 保证数据的完整性和一致性
- 级联操作方便
- 将数据完整性判断托付给了数据库完成，减少了程序的代码量

然而，鱼和熊掌不可兼得。外键是能够保证数据的完整性，但是会给系统带来很多缺陷。正是因为这些缺陷，才导致我们不推荐使用外键，具体如下

##### 性能问题

假设一张表名为user_tb。那么这张表里有两个外键字段，指向两张表。那么，每次往user_tb表里插入数据，就必须往两个外键对应的表里查询是否有对应数据。如果交由程序控制，这种查询过程就可以控制在我们手里，可以省略一些不必要的查询过程。但是如果由数据库控制，则是必须要去这两张表里判断。

##### 并发问题

在使用外键的情况下，每次修改数据都需要去另外一个表检查数据,需要获取额外的锁。若是在高并发大流量事务场景，使用外键更容易造成死锁。

##### 扩展性问题

这里主要是分为两点

- 做平台迁移方便，比如你从`Mysql`迁移到`Oracle`，像触发器、外键这种东西，都可以利用框架本身的特性来实现，而不用依赖于数据库本身的特性，做迁移更加方便。
- 分库分表方便，在水平拆分和分库的情况下，外键是无法生效的。将数据间关系的维护，放入应用程序中，为将来的分库分表省去很多的麻烦。

##### 技术问题

使用外键，其实将应用程序应该执行的判断逻辑转移到了数据库上。那么这意味着一点，数据库的性能开销变大了，那么这就对DBA的要求就更高了。很多中小型公司由于资金问题，并没有聘用专业的DBA，因此他们会选择不用外键，降低数据库的消耗。
相反的，如果该约束逻辑在应用程序中，发现应用服务器性能不够，可以加机器，做水平扩展。如果是在数据库服务器上，数据库服务器会成为性能瓶颈，做水平扩展比较困难。



## 第二章 mysql使用技巧

### 组合查询

**UNION**的使用很简单。所需做的只是给出每条SELECT语句，在各条语
句之间放上关键字UNION。

举一个例子，假如需要价格小于等于5的所有物品的一个列表，而且
还想包括供应商1001和1002生产的所有物品(不考虑价格)。当然，可以
利用WHERE子句来完成此工作，不过这次我们将使用UNION。

输入1：

![image-20191124145544459](/Users/itheima/Library/Application Support/typora-user-images/image-20191124145544459.png)

![image-20191124145554904](/Users/itheima/Library/Application Support/typora-user-images/image-20191124145554904.png)


输入2：

![image-20191124145615294](/Users/itheima/Library/Application Support/typora-user-images/image-20191124145615294.png)

![image-20191124145707756](/Users/itheima/Library/Application Support/typora-user-images/image-20191124145707756.png)

第一条SELECT检索价格不高于5的所有物品。第二条SELECT使
用IN找出供应商1001和1002生产的所有物品。

**为了组合这两条语句，按如下进行:**

![image-20191124150411367](/Users/itheima/Library/Application Support/typora-user-images/image-20191124150411367.png)



### 全文本搜索

前面介绍了LIKE关键字，它利用通配操作符匹配文本(和部分文
本)。使用LIKE，能够查找包含特殊值或部分值的行(不管这些值位于列
内什么位置)。

虽然这些搜索机制非常有用，但存在几个重要的限制。

- 性能——通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行(而且这些搜索极少使用表索引)。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。

- 明确控制——使用通配符和正则表达式匹配，很难(而且并不总是能)明确地控制匹配什么和不匹配什么。例如，指定一个词必 须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配的 情况下才可以匹配或者才可以不匹配。 

  > 所有这些限制以及更多的限制都可以用全文本搜索来解决。在使用
  > 全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理
  > 每个词。MySQL创建指定列中各词的一个索引，搜索可以针对这些词进
  > 行。这样，MySQL可以快速有效地决定哪些词匹配(哪些行包含它们)，
  > 哪些词不匹配，它们匹配的频率，等等。

为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改 变不断地重新索引。在对表列进行适当设计后，MySQL会自动进行所有 的索引和重新索引。 

在索引之后，SELECT可与Match()和Against()一起使用以实际执行 搜索。 

#### 启用全文本搜素支持

一般在创建表时启用全文本搜索。CREATE TABLE语句(第21章中介绍)接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。 

![image-20191124152312498](/Users/itheima/Library/Application Support/typora-user-images/image-20191124152312498.png)

> 不要在导入数据时使用FULLTEXT 更新索引要花时间，虽然
> 不是很多，但毕竟要花时间。如果正在导入数据到一个新表，
> 此时不应该启用FULLTEXT索引。应该首先导入所有数据，然
> 后再修改表，定义FULLTEXT。这样有助于更快地导入数据(而
> 且使索引数据的总时间小于在导入每行时分别进行索引所需
> 的总时间)。

#### 进行全文本搜索

在索引之后，使用两个函数Match()和Against()执行全文本搜索， 

其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。 

![image-20191124152440099](/Users/itheima/Library/Application Support/typora-user-images/image-20191124152440099.png)

此SELECT语句检索单个列note_text。由于WHERE子句，一个全 

文本搜索被执行。Match(note_text)指示MySQL针对指定的 列进行搜索，Against('rabbit')指定词rabbit作为搜索文本。由于有 两行包含词rabbit，这两个行被返回。 

> 使用完整的Match()说明 传递给Match()的值必须与
> FULLTEXT()定义中的相同。如果指定多个列，则必须列出它
> 们(而且次序正确)。

> 搜索不区分大小写 除非使用BINARY方式(本章中没有介绍)，
> 否则全文本搜索不区分大小写。

#### 布尔文本搜索

MySQL支持全文本搜索的另外一种形式，称为布尔方式(boolean 

mode)。以布尔方式，可以提供关于如下内容的细节: 

> 即使没有FULLTEXT索引也可以使用 布尔方式不同于迄今为 止使用的全文本搜索语法的地方在于，即使没有定义 FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作 
>
> (其性能将随着数据量的增加而降低)。 

![image-20191124152921065](/Users/itheima/Library/Application Support/typora-user-images/image-20191124152921065.png)

### 什么是索引

MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。

打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。

索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。

创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。

实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。

上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。

**建立索引会占用磁盘空间的索引文件。**

> 使用空间换时间

#### 索引类型

Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。

1. **FULLTEXT**
即为全文索引，目前只有MyISAM引擎支持（5.7以上的版本，innoDB已经支持）。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。

全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。

2. **HASH**
由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。

HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。

3. **BTREE**
BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。

4. **RTREE**
RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。

相对于BTREE，RTREE的优势在于范围查找。


#### 索引种类

- 普通索引：仅加速查询
- 唯一索引：加速查询 + 列值唯一（可以有null）
- 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
- 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- 全文索引：对文本的内容进行分词，进行搜索



### MyISAM与InnoDB两者之间区别与选择

1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； 

2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； 

3. InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。


>      MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
>     
>        也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。

![image-20191124155702635](/Users/itheima/Library/Application Support/typora-user-images/image-20191124155702635.png)

![image-20191124155713106](/Users/itheima/Library/Application Support/typora-user-images/image-20191124155713106.png)

4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；

5. Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；5.7以后的InnoDB支持全文索引了

6. MyISAM表格可以被压缩后进行查询操作

7. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁

       InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。

8、InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有

9、Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI

        Innodb：frm是表定义文件，ibd是数据文件
    
        Myisam：frm是表定义文件，myd是数据文件，myi是索引文件
#### 如何选择

    1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
    
    2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。
    
    3. 系统奔溃后，MyISAM恢复起来更困难，能否接受；
    
    4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。

## 第三章 mysql数据结构与性能优化

### 索引的本质

MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。

我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如[二分查找](http://www.codeceo.com/article/binary-search.html)（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

![image-20191201191117336](assets/image-20191201191117336.png)

图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)O(log2n)的复杂度内获取到相应数据。

虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。

### B树

目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。

- 基于 2-3树

> 2-3树是一种绝对平衡的二叉树永远不会出现左右不平衡的情况

![image-20191201194613881](assets/image-20191201194613881.png)

### B + 树

B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。

与B-Tree相比，B+Tree有以下不同点：

每个节点的指针上限为2d而不是2d+1。

内节点不存储data，只存储key；叶子节点不存储指针。

图3是一个简单的B+Tree示意。

![image-20191201205326197](assets/image-20191201205326197.png)

由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。

一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。

### 带有顺序访问指针的B+Tree

一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。

![image-20191201205359165](assets/image-20191201205359165.png)

如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。

### 为什么使用B-Tree（B+Tree）

上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。

#### 主存存取原理

目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。

![image-20191201205514350](assets/image-20191201205514350.png)

从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。

主存的存取过程如下：

当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。

写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。

这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取[D3](http://www.codeceo.com/article/javascript-d3-js.html)的时间消耗是一样的。

#### 磁盘存取原理

上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。

图6是磁盘的整体结构示意图。

![image-20191201205546891](assets/image-20191201205546891.png)

一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。

图7是磁盘结构的示意图。

![image-20191201205603150](assets/image-20191201205603150.png)

盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。

当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。

#### 局部性原理与磁盘预读

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：

当一个数据被用到时，其附近的数据也通常会马上被使用。

程序运行期间所需要的数据通常比较集中。

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

#### B-/+Tree索引的性能分析

到这里终于可以分析B-/+Tree索引的性能了。

上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：

每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

综上所述，用B-Tree作为索引结构效率是非常高的。

而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：

dmax=floor(pagesize/(keysize+datasize+pointsize))dmax=floor(pagesize/(keysize+datasize+pointsize))

floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。

这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。



### 索引性能优化

MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。

#### 最左前缀原理与相关优化

高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。

这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组<a1, a2, …, an>，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。

以employees.titles表为例，下面先查看其上都有哪些索引：

![image-20191201220331731](assets/image-20191201220331731.png)

##### 情况一：全列匹配。

![image-20191201220411262](assets/image-20191201220411262.png)

很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：

![image-20191201220429594](assets/image-20191201220429594.png)

效果是一样的。

##### 情况二：最左前缀匹配。

![image-20191201220457578](assets/image-20191201220457578.png)

当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或<emp_no, title>，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。

##### 情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。

![image-20191201220518106](assets/image-20191201220518106.png)

此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引<emp_no, from_date>，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。

首先我们看下title一共有几种不同的值：

![image-20191201220543488](assets/image-20191201220543488.png)

只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：

![image-20191201220600012](assets/image-20191201220600012.png)

这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：

![image-20191201220620350](assets/image-20191201220620350.png)

##### 情况四：查询条件没有指定索引第一列。

![image-20191201220641378](assets/image-20191201220641378.png)

由于不是最左前缀，索引这样的查询显然用不到索引。

#### InnoDB的主键选择与插入优化

在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。

经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。

上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：

![image-20191201220850194](assets/image-20191201220850194.png)

这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。

如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：

![image-20191201220920016](assets/image-20191201220920016.png)

此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

**因此，只要可以，请尽量在InnoDB上采用自增字段做主键。**